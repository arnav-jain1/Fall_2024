# Intro
When making a language, we need to describe what each syntax means. You have to know what the language is supposed to do before we can test it
- Define concrete syntax of new language
- Define the meaning of each syntactic element
	- Evaluation semantics tells us what it does (execution)
	- Static semantics tells us what we can predict (type checking)
3 ways of doing this 
- denotational: map each language structure to a mathematical function 
- operational: Define how legal strings in a language are evaluated
- Axiomatic: Define pre- and post- conditions on execution of language constructs

# Compilers and interpreters 
## Language processing (exam)
Two styles: Compiler and interpreter
- Compiler turns code into an executable form (binary)
	- Source language is the language being translated
	- Target language is the language being translated to
- Interpreters define a function that executes the language directly. It is not put into another form but executed directly
	- Embedded language is the language being interpreted 
	- Host language is the known language that defines the interpreter

## Defining syntax
*Programs are data structures*
Define syntax using syntax rules
Simple arithmitic expression
```haskell
AE ::= num
	| AE + AE
	| AE - AE
	| (AE)
```
AE is an infinite set
Examples:
```haskell
4
1 + 3
(2 + 2) + (5 - 7)
1 + 3 - (5 + (8 - 4))
```
Non-examples:
```haskell
+ 4
3 * 2
)(
```
Concrete syntax: what programmers write, strings (boring)
abstract syntax: what interpreters operate over- the data structure! 

```haskell
data AE where
	Num :: Int -> AE
	Plus :: AE -> AE -> AE
	Minus :: AE -> AE -> AE
	deriving (Show, Eq)

(Num 3)
(Plus (Num 4) (Num 7)); 4 + 7
```

- AE = type name
- Num, plus, minus = Constructors, make elements of type
- AE -> AE: signature 
- Defines all constructors 

parser: concrete syntax -> abstract syntax 
`parse 1+3 == (Plus (Num 1) (Num 3))`

# Interpreters
Interpreter takes a language and maps it to a value:
$$ E : L \rightarrow V$$
Where E is an interpreter, L is our language, and V is our value
Values cannot be evaluated further (cant be broken up more)

Simplest syntax
```haskell
AE ::= num
```
Abstract syntax: 
```haskell 
data AE where
	Nat :: Int -> AE
	(deriving Eq,Show)
```
(deriving Eq, Show) = gets the eq and show functions so that you can compare and print stuff
Nat contructor
```haskell
eval :: AE -> Int
```
Parser translate number into AE
```haskell
parse "1" == (Nat 1)
parse "2" == (Nat 2)
parse "a" == !
parse "1+2" == !
```
`!` = bang
`?` = hook
`*` = splat
`#!` = shebang

Interpreter will translate AE into values
```haskell
eval::AE-> Int
eval (Nat x) = x
```
Put it all together
```haskell 
interp x = eval (parse x)

interp "1" == 1
interp "3" == 3
```
OR 
```haskell
interp = eval . parse
```
Adding addition
``` haskell
data AE where
	Nat :: Int -> AE
	Plus :: AE -> AE -> AE
	(deriving Eq, Show)

eval::AE->Int
eval (Nat x) = x
eval (Plus x y) = (eval x) + (eval y)

eval (Plus (Nat 1) (Nat 3)) 
== (eval (Nat 1)) + (eval (Nat 1))
== 1 + 3
== 4
```
Do programs in AE Terminate? Yes
Do programs ever crash? No
cant do much tho 


``` haskell
data AE where
	Nat :: Int -> AE
	Plus :: AE -> AE -> AE
	(deriving Eq, Show)

eval::AE->Int
eval (Nat x) = x
eval (Plus x y) = (eval x) + (eval y)
eval (Minus l r) = let x = (eval  l) - (eval r) in 
						if x <0 then error "!" else x
```
You can also use a *magic number* which is a number indicating there is being a problem without ending the problem.
	You can set the magic value to -1 so it returns that instead of error but it sucks because it is hard to tell what is going on
This is helped by *maybe*
```haskell
data Maybe A =
	Just :: A -> Maybe A
	Nothing :: Maybe A
```

## Monad
Using Maybe
```haskell
eval::AE -> Maybe Int
eval (Nat x) = Just x
eval (Plus l r) = do { x <- eval l;
					   y <- eval r;
					   Just (x + y) }
eval (Minus l r) do { x <- eval l;
					  y <- eval r;
					  if x >= y then Just (x - y) else Nothing
	
}
```

x `<-` is called a bind and we bind the output of the right side to the left. Only works if it is a monad
Can also replace Just with return

We can change the signature to `eval::AE -> Maybe AE` if we want to return bools instead of ints

; is a sequence operator which means do it in order.


### Language properties
wff - Well formed formula ("woof")
Completeness - every wff that we put into eval will get evaluated
Determinicity - every wff we put into eval will produce only one value
Normalizing- every wff we put into eval will terminate in a value
Value- A good computation result
