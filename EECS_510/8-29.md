# Formal languages and Finite State Machines
3 forms of theory
* Complexity theory (why are some problems computationally hard and others easy)
* Computability theory (what problems are solvable vs not solvable)
* Automata Theory (definitions and properties of mathmatical models of computation)
	* Finite automata is one model
	* Used in text-processing, hardware design, compiles

# Definitions
Computation
* Execution of a self-contained procedure that processes input without outside intervention once it starts, and eventually halts yielding output that corresponds to input given
* "black box"
Procedure
* A computing mechanism we call an abstract machine; theoretical model allowing for precise analysis of how a system functions
* some underlying mathematical model
Algorithms 
* Computation that **Always** halts
Language
* A set of strings with some inherent structure used to express a computation



## Kleene Star
Imagine you have a set of letters (or strings) $\{a,b\}$. The kleene star group is the infinite set of all of the possible combinations created by the elements of the group so:
$V^{*}= \sum^{*}= \{ \lambda, a, b, aa, ab, ba, bb, ...\}$

We can do operations on these languages so let 
$$x = bab, y = abbaab $$
- Length: |x| = 3
- Concatenation: $xy = bababbaab$
- Repetition: $x^{3} = babbabbab$, $x^{0} = \lambda$
- Reversal: $y^{R} = baabba$
- Kleene Star: $x^{*}=\{\lambda,bab,babbab,...\}, \{\lambda, x, xx, xxx\}$

Example: Kleene star of $S = \{x,y\}$ where
$$x = bab, y = abbaab $$
$S^{*} = \{\lambda, x, y, xx, yx, xy, xxx,...\}$
$S^{*} = \{\lambda, bab, abbaab, babbab, abbaabbab, bababbaab, babbabbab...\}$
**Note:** order matters where you order by length first and then alphabetical order (why yy is after xxx and why xy is after yx)
**Note 2:** You also have to define alphabetical order

Example2: Given the alphabet $\sum = \{a,b\}$ and $S = \{aa,ab,ba,bb\}$
generate $S^{*}$
$$S^{*}=\{\lambda, aa, ab, ba, bb, aaaa, aaab, aaba, aabb, abaa,...\}
$$
Note: referring $S^{*} = L_{e}$ 
You can generate all possible strings in $L_{e}$ using a set of substitution roles called **formal grammar**. 
$$E \rightarrow \lambda | aO | bO$$
$$ O \rightarrow aE | bE$$
How to make $baaa$ using formal grammar
$$E \Rightarrow bO \Rightarrow baE \Rightarrow baaO \Rightarrow baaaE \Rightarrow baaa\lambda$$

Another formal grammar:
$$E \rightarrow \lambda \space|\space aaE \space| abE \space| \space baE \space| \space bbE$$
# Finite state machine

Create a machine using grammar of $L_{e}$
We need 2 states: E and O
Our first state is E
$$ \rightarrow E \space\space\space\space\space\space\space\space\space O$$
We can go between states?
```tikz
\usetikzlibrary{automata,arrows}

\begin{document}

\begin{tikzpicture}[
    ->,
    >=stealth,
    node distance=3cm,
    every state/.style={thick, fill=gray!10}
]

    \node[state, initial] (E) {$E$};
    \node[state, right of=E] (O) {$O$};
    
    \path (E) edge[bend left] node[above] {a,b} (O)
          (O) edge[bend left] node[below] {a,b} (E);

\end{tikzpicture}

\end{document}
```
Double circle around end state

Examples:
Alphabet is 0,1 and ends with 1
![[Pasted image 20240905080545.png]]
Automata for removing comments
![[Pasted image 20240905080628.png]]
# Summary
Computation: Meaningful manipulation of symbols
	Need formal languages to describe input, output, operations
Formal languages generated using grammars
Recognized and used by finite-state machines called automata
3 major classes of the formal languages


| Language Class         |   Recognized by   |     Generated by     |
| ---------------------- | :---------------: | :------------------: |
| Regular                |  Finite Automata  | Regular Grammar/Expr |
| Context-Free           | Pushdown automata | Context-free Grammar |
| Recursively Enumerable |  Turing Machine   | Unrestricted grammar |

# Deterministic Finite Automata (DFA)
Finite state machine with:
	Q, set of states
		One is the start state 
		rest is a subset that are final (or accepting) states
	$\sum_{t}$  Alphabet of valid input symbols
	$\delta_{t}$ (delta, used to denote change or transition). Function where
$$\delta : Q \times \sum \rightarrow Q$$
$Q \times E =$ the set of all ordered pairs (x,y) such that x belongs to Q and y belongs to $\sum$ 
So if $Q = \{s_{1}, s_{2}\}$ and $\sum = \{a,b\}$ 
$Q \times \sum = (s_{0},a),(s_{0},b), (s_{1},a), (s_{1},b)$

1. The transition function $\delta$ are the edges (transitions) of machine
2. The subset of Q that comprises the final state could be empty (infinite loop)
	1. Machines that have an output string may have no final state
3. Must be exactly ONE transition out of every state

![[Pasted image 20240905080651.png]]
The set of states $Q = \{q_{0}, q_{1}\}$  and alphabet $\sum = \{a,b\}$
$\delta = \{((q_{0}, a), q_{0}), ((q_{0}, b), q_{1}) ((q_{1}, a), q_{0}), (q_{1}, b), q_{1} \}$ 

3rd way to represent DFA which is a transition table: 

| State  | a     | b     |
| ------ | ----- | ----- |
| $q_0$  | $q_0$ | $q_1$ |
| $+q_1$ | $q_1$ | $q_0$ |

```python
def ends_with_b(s):
	transitions = {('q0', 'a'): 'q0',
				   ('q0', 'b'): 'q1',
				   ('q1', 'a'): 'q0',
				   ('q1', 'b'): 'q1' }
	state = 'q0'
	for c in s:
		state = transitions[(state,c)]
	return 'accepted' if state == 'q1' else 'rejected'

print(ends_with_b('aabab')) # accepted
print(ends_with_b('ababa')) # rejected
```

DFA that accepts all strings over alphabet {a,b} that ends with ab

DFA that accepts all strings with aba in it 
![[Pasted image 20240905084314.png]]

Finding the complement (opposite)of DFAs you just swap not the exits
(may make a loop)
So 0, 1, 2 are exits and 3 is not

### Jail states 
States that you can't 'leave', created for states we don't ever want to see which is fine and sometimes intended

*Regular language*: a formal language for a DFA that accepts all and only the strings in language

# Non deterministic Machines
Machines where you have the same number that leads to 2 different paths
![[Pasted image 20240905090132.png]]
here you have 2 options for A at 0 that do different things


if you see a $\lambda$ it makes the other char optional, moves from what state to another without consuming any input