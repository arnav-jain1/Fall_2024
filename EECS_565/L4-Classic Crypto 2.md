# Vigenere
## Cracking Vigenere
Need key length 
	Split it into blocks and the nth letter of each block is decrypted by the same key
Crack every possible key combination like its a shift cipher
To try every possible key its $26^{n}$ where n is length of key
To check if decryption is successful check it with a dictionary 

### Freq analysis
Index of coincidence
	Measure of similarity between frequency distribution and uniform distribution
	![[Pasted image 20240911111709.png]]Calculates the probability of choosing two letters at random where they are the same
	N = length of ciphertext
	n = length of alphabet (26)
	$F_{i}$ = number of occurance of ith letter in the alphabet
![[Pasted image 20240911112007.png]]
If the IC of a ciphertext is close to IC of english, it means that the plaintext is English with a subst cipher 
For polyalphabetic, we create strings that are created by same key letter and test IC 
	IE, make a string of every 4th letter (key length = 4). There will be 4 total (starting with letter 0, 1, 2, and 3) and then find the average IC 

Brute forcing is how to crack Vigenere which means the longer the key the better (also less repeats)

# Vernam Cipher
Key is the same length as plain text
Use a stream of random data as a key 
Also known as *One time pad* cipher
Each bit of the key stream is used to encrypt each bit of plain text using XOR
	Uniform output that is length of input
	also known as mod 2 operation
The key is the same for encrypt and decrypt

Works because:
$k \bigoplus k = 0$  so if p = ciphertext then $p \bigoplus k \bigoplus k = p$ 
Example:
	Let text = Cafe and key = "00100001010010000001111101001111"
	![[Pasted image 20240911113142.png]]

Advantages:
1. Perfect secrecy, in theory OTP is impossible to crack
	Key is random and as long as plain text
	Since a plaintext can be anything, all plain texts are equally likely even if the attacker can brute force
	*Assuming truly random key*
2. XOR is Easy and fast to compute and is the same operations both ways
Disadvantages:
1. Key is as long as the plain text, which means very long and impractical for most cases
2. Key is never truly random
3. can't reuse key because you can learn the relationship between plaintexts 
4. No integrity, only confidentiality (can't recover plain text, but can change the ciphertext)
#### side note, randomness in computers
Random nums generated by pseudorandom number generators (PRNGs)
- /dev/random (blocking, waits for enough entropy)
- /dev/urandom (nonblocking, less entropy)
- getrandom() (blocking)
What is entropy? "random" noise from outside sources like network timing, keyboard, mouse, etc

# Transposition cipher
Substitution: Swap one bits for another, adds *confusion*
Transposition adds *diffusion*
rearrange the letters to get ciphertext
	P = jayhawk
	C = whkayaj
	K = 6472351

## Columnar transpotition
2d array where plain text is rows, the ciphertext becomes the columns
![[Pasted image 20240911114724.png]]
P = ROCKCHALKJAYHAWK
C = RHAKOAYCLHKKACJW
You can even reorder the columns CLHOAYCJWKKARHAK

Most transpositions use a fixed period d
- Let $Z_{d}$ be ints from 1 to d
- Let $f:Z_{d} \rightarrow Z_{d}$ be a permutation over $Z_{d}$
- The key id (d,f) where d is the period and f is the function
- Message is $M_{1}, M_{2} ... , M_{d}, M_{d+1}, M_{d+2}, ...$
- Ciphertext is $C=m_{f(1)}, m_{f(2)}, ... , m_{f(d)}. d + m_{f(1)}, ..., m_{d+f(d)}$ 

Example: 
	Pick the key period d=4
	Chose the permutation: 1->2, 2->4, 4->3, 3->1 
		If i = 1-4, then f(i) = 2, 4, 3, 1
	P = ROCK CHAL K
	C = OKRC HLCA K

To crack, use letter pairs and triples (bigrams and trigrams) to get d
Transposition is just a rearangement (permutation)
Usually both are combined 

# Cipher design techniques
Substitution: Change one set of bits for another (swap letters) *confusion*
Transposition: Rearrange order of ciphertext to break repeated patterns *diffusion*

## Combination
Confusion: make the relationship between plaintext and ciphertext as complex as possible (key use is complicated)
	Change in plaintext changes ciphertext very complicatedly 
	Encrypt
Diffusion: Change the structure of plaintext
	Change in plaintext affects many parts of ciphertext

Shannon Secrecy:
	P(guessing plaintext | ciphertext) = P(guessing plaintext without knowing ciphertext) 
		$P(M = m | c = E(K,m)) = P(M = m)$
	Probability of any text having a ciphertext is the same
		$P(c = E(K,m)) = P(c=E(K,m'))$ 
Shannon theory:
	Perfect secrecy $\iff$ number of Keys = number of plaintext and every key is equally likely 
		$n_{K}=n_{P} AND P(K_{1}) == P(K_{2})$
Substitution-Permutation networks (S-P): Uses both subst (s-box) and permutation (diffusion, p box)


in Good cryptosystem it is impossible to:
	number all keys
	Find key from reasonable amount of ciphertext/plaintext by enumerating possible keys
	produce plaintext from ciphertext without key
	see the difference between ciphertext from true random values


## Restricted algorithm: "security by obscurity"
Algo a secret 
Security of algo depends on secrecy 
TERRIBLE idea
	can't be used by large or changing group
	if algo is exposed, must change
	different groups need diff algos 
	Difficult to design and prove cipher
	The users are not the designers

***SYSTEM MUST NOT BE A SECRET. it must be able to fall into the enemy's hands without issue***
Assume that enemy has access to and can reverse engineer algorithm 
Security must *only* depend on the secret key (random)
