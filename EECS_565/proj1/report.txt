The plaintexts that have been cracked are all in output.png

The first 3 were all cracked under a second while the 4th took 3 seconds and the 5th took 2 minutes. The 6th was a lot longer and took a little over an hour to finish. The reason it was able to be so fast was because everything was multithreaded, all of my computer was being used. The general design of the cracker was to generate all possible key combinations first, then go through them all using subfunctions and multithreading. This proved to be a lot faster than cracking while generating as that was another thing that I tried. Though this method was a lot faster, it used up more ram since all the possible key combinations (26^n) were being stored in RAM. For n=7, I ran out of RAM so I had to create all possible key combinations of 6, then add each possible letter to it to get all possible combinations of 7. I also tried using the threads library which was also a bit slower.
1 way to further speed this up would be to use more compute (more cores or even maybe GPU programming). Another way would be to use a much faster compiled language like Go or C++ that just runs faster than python overall. Overall, password cracking is very inneffecient. Time time complexity is O(26^n) where n is the length of the key. This also assumes the length of the key is known. If we only know the maximum key length then it becomes even longer because we have to try key length of 1, key length of 2 ... key length of n. All in all cracking algorithms are extremely slow. Small optimizations were made like using hashmaps and sets which have a O(1) lookup time compared to O(n). Another idea I had was to remove any calculation when ciphertext to plaintext by making a 26 x 26 hashmap table that has all possible letters and shifts, though this would be a small difference in speed. 

