Memory is limited, usage keeps going up
# Background info
CPU can only directly access memory or registers
	Instructions and data must be in memory to be accessed

Memory is just a large array of bytes
Accessing it is slow (compared to register/cache)
	Cache faster because smaller and closer (on CPU)
	Memory takes more clock cycles to access and you have to take a BUS
Memory needs to be protected 


# Old model
OS is generally placed in low memory address (for interrupt vector tables)
![[Pasted image 20241111140957.png]]
Each process has its own address space assigned to it with a base and limit (stored in registers)
If process requests address outside the range, then seg fault


# Address binding
Instructions and data is all binded (stored) in memory addresses 
There are 3 possible times where addresses can be bounded:
	1. Compile time: If the location of the memory is known at compile time, absolute code can be generated (will have to recompile if address changes)
		Can be done when using obj files
		Necessary that the generated address places are placed at the right places
		location should be free when running
	2. load time: Compiler has to generate relocatable binary if the memory location is unknown at compile time (code placable anywhere in memory)
	3. Execution time: Binding delayed until runtime to allow program to move while being ran
		Need hardware support but most flexible 
		Most common way but has overhead
![[Pasted image 20241111141344.png]]

When you compile normally, the instructions are symbolic with no actual values, instead relative values

Logical address space (generated by CPU) is bound to a physical address space
	Changed by the OS
Logical == physical in compile-time and load-time
Different in execution time


## MMU, memory management unit
Hardware that maps a virtual address to a physical address
Simple scheme:
	Start process's logical address at 0
	Max address stored in limit register
	Base memory address stored in relocation register
	The physical address is added to the relocation register 
![[Pasted image 20241111143404.png]]
Range for virtual: 0 to limit register
Range for physical: relocation register to relocation register + limit register
Done in hardware because faster

In compiletime/load time, does not exist 


## Dynamic loading
Static loading:
	entire program is in memory before program starts
	Program size is limited
Dynmaic loading:
	Routine not loaded until called
	Better util, unused routine never loaded (like with if else blocks)
	Useful for edge cases
	No support from OS, implemented through program design
